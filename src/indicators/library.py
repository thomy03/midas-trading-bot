"""
Indicator Library - Central Registry for all technical indicators.

This module provides a unified interface for all indicators that can be
used by the Strategy Composer to build trading strategies dynamically.

Each indicator follows a standard interface:
- compute(df, **params) -> pd.Series or pd.DataFrame
- get_signal(df, **params) -> Dict with signal info
- get_params() -> Dict of available parameters with defaults
"""

import pandas as pd
import numpy as np
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from typing import Dict, Any, List, Optional, Callable, Union
from enum import Enum


class IndicatorCategory(Enum):
    """Categories of technical indicators"""
    MOMENTUM = "momentum"
    TREND = "trend"
    VOLUME = "volume"
    VOLATILITY = "volatility"
    PATTERN = "pattern"
    SENTIMENT = "sentiment"


class SignalType(Enum):
    """Types of trading signals"""
    BULLISH = "bullish"
    BEARISH = "bearish"
    NEUTRAL = "neutral"


@dataclass
class IndicatorSignal:
    """Represents a signal generated by an indicator"""
    indicator_name: str
    signal_type: SignalType
    strength: float  # 0.0 to 1.0
    value: float  # Current indicator value
    threshold: Optional[float] = None  # Threshold that triggered signal
    message: str = ""
    timestamp: Optional[pd.Timestamp] = None


@dataclass
class IndicatorMetadata:
    """Metadata about an indicator"""
    name: str
    category: IndicatorCategory
    description: str
    default_params: Dict[str, Any]
    param_ranges: Dict[str, tuple]  # (min, max) for each param
    outputs: List[str]  # Column names this indicator produces
    dependencies: List[str] = field(default_factory=list)  # Other indicators needed


class BaseIndicator(ABC):
    """
    Base class for all technical indicators.

    All indicators must implement:
    - compute(): Calculate the indicator values
    - get_signal(): Generate trading signals based on indicator values
    """

    def __init__(self, **params):
        """Initialize with custom parameters"""
        self.params = {**self.get_default_params(), **params}
        self._validate_params()

    @classmethod
    @abstractmethod
    def get_metadata(cls) -> IndicatorMetadata:
        """Return metadata about this indicator"""
        pass

    @classmethod
    def get_default_params(cls) -> Dict[str, Any]:
        """Get default parameters for this indicator"""
        return cls.get_metadata().default_params

    @classmethod
    def get_param_ranges(cls) -> Dict[str, tuple]:
        """Get valid ranges for each parameter"""
        return cls.get_metadata().param_ranges

    def _validate_params(self):
        """Validate that parameters are within acceptable ranges"""
        ranges = self.get_param_ranges()
        for param, value in self.params.items():
            if param in ranges:
                min_val, max_val = ranges[param]
                if not (min_val <= value <= max_val):
                    raise ValueError(
                        f"Parameter '{param}' value {value} is outside "
                        f"valid range [{min_val}, {max_val}]"
                    )

    @abstractmethod
    def compute(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Compute the indicator and add columns to the dataframe.

        Args:
            df: DataFrame with OHLCV data (Open, High, Low, Close, Volume)

        Returns:
            DataFrame with indicator columns added
        """
        pass

    @abstractmethod
    def get_signal(self, df: pd.DataFrame) -> Optional[IndicatorSignal]:
        """
        Get the current trading signal from the indicator.

        Args:
            df: DataFrame with indicator columns already computed

        Returns:
            IndicatorSignal if a signal is present, None otherwise
        """
        pass

    def get_current_value(self, df: pd.DataFrame) -> float:
        """Get the most recent indicator value"""
        outputs = self.get_metadata().outputs
        if outputs and outputs[0] in df.columns:
            return df[outputs[0]].iloc[-1]
        return np.nan


class IndicatorRegistry:
    """
    Central registry for all available indicators.

    Usage:
        registry = IndicatorRegistry()
        registry.register(RSI)
        registry.register(MACD)

        # Get indicator instance
        rsi = registry.get('RSI', period=14)
        df = rsi.compute(df)
        signal = rsi.get_signal(df)

        # List all available indicators
        all_indicators = registry.list_all()
    """

    _instance = None

    def __new__(cls):
        """Singleton pattern"""
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._indicators = {}
            cls._instance._initialized = False
        return cls._instance

    def register(self, indicator_class: type):
        """Register an indicator class"""
        if not issubclass(indicator_class, BaseIndicator):
            raise TypeError(f"{indicator_class} must inherit from BaseIndicator")

        metadata = indicator_class.get_metadata()
        self._indicators[metadata.name] = indicator_class

    def get(self, name: str, **params) -> BaseIndicator:
        """Get an indicator instance by name with custom parameters"""
        if name not in self._indicators:
            raise KeyError(f"Indicator '{name}' not found. Available: {list(self._indicators.keys())}")

        return self._indicators[name](**params)

    def get_class(self, name: str) -> type:
        """Get the indicator class by name"""
        if name not in self._indicators:
            raise KeyError(f"Indicator '{name}' not found")
        return self._indicators[name]

    def list_all(self) -> List[IndicatorMetadata]:
        """List metadata for all registered indicators"""
        return [cls.get_metadata() for cls in self._indicators.values()]

    def list_by_category(self, category: IndicatorCategory) -> List[IndicatorMetadata]:
        """List indicators in a specific category"""
        return [
            cls.get_metadata()
            for cls in self._indicators.values()
            if cls.get_metadata().category == category
        ]

    def get_names(self) -> List[str]:
        """Get list of all registered indicator names"""
        return list(self._indicators.keys())

    def to_dict(self) -> Dict[str, Dict]:
        """Export registry as dictionary (for LLM prompts)"""
        result = {}
        for name, cls in self._indicators.items():
            meta = cls.get_metadata()
            result[name] = {
                'category': meta.category.value,
                'description': meta.description,
                'params': meta.default_params,
                'param_ranges': {k: list(v) for k, v in meta.param_ranges.items()},
                'outputs': meta.outputs
            }
        return result


# Global registry instance
_registry = None


def get_indicator_registry() -> IndicatorRegistry:
    """Get the global indicator registry"""
    global _registry
    if _registry is None:
        _registry = IndicatorRegistry()
        # Auto-register all indicators
        _auto_register_indicators(_registry)
    return _registry


def _auto_register_indicators(registry: IndicatorRegistry):
    """Auto-register all indicator classes from submodules"""
    try:
        from . import oscillators
        for cls in oscillators.INDICATORS:
            registry.register(cls)
    except (ImportError, AttributeError):
        pass

    try:
        from . import trend
        for cls in trend.INDICATORS:
            registry.register(cls)
    except (ImportError, AttributeError):
        pass

    try:
        from . import volume
        for cls in volume.INDICATORS:
            registry.register(cls)
    except (ImportError, AttributeError):
        pass

    try:
        from . import volatility
        for cls in volatility.INDICATORS:
            registry.register(cls)
    except (ImportError, AttributeError):
        pass

    try:
        from . import patterns
        for cls in patterns.INDICATORS:
            registry.register(cls)
    except (ImportError, AttributeError):
        pass


def compute_indicator(name: str, df: pd.DataFrame, **params) -> pd.DataFrame:
    """
    Convenience function to compute an indicator.

    Args:
        name: Indicator name (e.g., 'RSI', 'MACD')
        df: DataFrame with OHLCV data
        **params: Indicator parameters

    Returns:
        DataFrame with indicator columns added
    """
    registry = get_indicator_registry()
    indicator = registry.get(name, **params)
    return indicator.compute(df)


def get_signal(name: str, df: pd.DataFrame, **params) -> Optional[IndicatorSignal]:
    """
    Convenience function to get a signal from an indicator.

    Args:
        name: Indicator name
        df: DataFrame with OHLCV data (indicator will be computed if needed)
        **params: Indicator parameters

    Returns:
        IndicatorSignal if present, None otherwise
    """
    registry = get_indicator_registry()
    indicator = registry.get(name, **params)
    df = indicator.compute(df)
    return indicator.get_signal(df)


# Condition evaluators for strategy composition
class ConditionOperator(Enum):
    """Operators for condition evaluation"""
    GREATER_THAN = ">"
    LESS_THAN = "<"
    GREATER_EQUAL = ">="
    LESS_EQUAL = "<="
    EQUAL = "=="
    CROSSES_ABOVE = "crosses_above"
    CROSSES_BELOW = "crosses_below"


@dataclass
class IndicatorCondition:
    """
    Represents a condition on an indicator for strategy composition.

    Example:
        # RSI < 30 (oversold)
        condition = IndicatorCondition(
            indicator_name='RSI',
            params={'period': 14},
            operator=ConditionOperator.LESS_THAN,
            value=30
        )
    """
    indicator_name: str
    params: Dict[str, Any]
    operator: ConditionOperator
    value: Union[float, str]  # Can be number or another indicator output
    output_column: Optional[str] = None  # Which output column to use

    def evaluate(self, df: pd.DataFrame) -> pd.Series:
        """
        Evaluate this condition on the dataframe.

        Returns:
            Boolean Series indicating where condition is True
        """
        registry = get_indicator_registry()
        indicator = registry.get(self.indicator_name, **self.params)
        df = indicator.compute(df)

        # Get the indicator column to evaluate
        output_col = self.output_column or indicator.get_metadata().outputs[0]
        indicator_values = df[output_col]

        # Get comparison value
        if isinstance(self.value, str) and self.value in df.columns:
            compare_values = df[self.value]
        else:
            compare_values = self.value

        # Apply operator
        if self.operator == ConditionOperator.GREATER_THAN:
            return indicator_values > compare_values
        elif self.operator == ConditionOperator.LESS_THAN:
            return indicator_values < compare_values
        elif self.operator == ConditionOperator.GREATER_EQUAL:
            return indicator_values >= compare_values
        elif self.operator == ConditionOperator.LESS_EQUAL:
            return indicator_values <= compare_values
        elif self.operator == ConditionOperator.EQUAL:
            return indicator_values == compare_values
        elif self.operator == ConditionOperator.CROSSES_ABOVE:
            prev = indicator_values.shift(1)
            return (prev <= compare_values) & (indicator_values > compare_values)
        elif self.operator == ConditionOperator.CROSSES_BELOW:
            prev = indicator_values.shift(1)
            return (prev >= compare_values) & (indicator_values < compare_values)
        else:
            raise ValueError(f"Unknown operator: {self.operator}")
